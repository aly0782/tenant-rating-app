#pragma version >=0.2.0;

;; REITx Factory Smart Contract - Working version with storage

;; Storage layout:
;; admin_address | next_property_id | properties_dict | user_balances | paused

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore bounced messages
        return ();
    }
    
    slice sender = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    ;; Load storage
    slice ds = get_data().begin_parse();
    slice admin = ds~load_msg_addr();
    int next_prop_id = ds~load_uint(32);
    cell properties = ds~load_dict();
    cell user_balances = ds~load_dict();
    int paused = ds~load_uint(1);
    
    ;; Handle buy tokens operation (0x87654321)
    if (op == 0x87654321) {
        throw_if(402, paused);
        
        int property_id = in_msg_body~load_uint(32);
        int amount = in_msg_body~load_coins();
        
        ;; For now, just store the purchase
        ;; Create user balance key: property_id + sender_address_hash
        int user_key = property_id * 1000000000 + slice_hash(sender);
        
        ;; Get current balance
        (slice balance_slice, int found) = user_balances.udict_get?(256, user_key);
        int current_balance = found ? balance_slice~load_coins() : 0;
        
        ;; Update balance
        current_balance += amount;
        user_balances~udict_set(256, user_key, begin_cell().store_coins(current_balance).end_cell().begin_parse());
        
        ;; Save storage
        set_data(
            begin_cell()
                .store_slice(admin)
                .store_uint(next_prop_id, 32)
                .store_dict(properties)
                .store_dict(user_balances)
                .store_uint(paused, 1)
                .end_cell()
        );
        
        return ();
    }
    
    ;; Handle create property (admin only)
    if (op == 0x12345678) {
        throw_unless(401, equal_slices(sender, admin));
        
        ;; Increment property counter
        next_prop_id += 1;
        
        ;; Save storage
        set_data(
            begin_cell()
                .store_slice(admin)
                .store_uint(next_prop_id, 32)
                .store_dict(properties)
                .store_dict(user_balances)
                .store_uint(paused, 1)
                .end_cell()
        );
        
        return ();
    }
    
    ;; Unknown operation
    throw(0xffff);
}

;; Get next property ID
(int) get_next_property_id() method_id {
    slice ds = get_data().begin_parse();
    ds~load_msg_addr(); ;; skip admin
    return ds~load_uint(32);
}

;; Check if paused
(int) is_paused() method_id {
    slice ds = get_data().begin_parse();
    ds~load_msg_addr(); ;; skip admin
    ds~load_uint(32); ;; skip next_property_id
    ds~load_dict(); ;; skip properties
    ds~load_dict(); ;; skip user_balances
    return ds~load_uint(1);
}

;; Get user balance for a property
(int) get_user_balance(int property_id, slice user_address) method_id {
    slice ds = get_data().begin_parse();
    ds~load_msg_addr(); ;; skip admin
    ds~load_uint(32); ;; skip next_property_id
    ds~load_dict(); ;; skip properties
    cell user_balances = ds~load_dict();
    
    ;; Create user balance key
    int user_key = property_id * 1000000000 + slice_hash(user_address);
    
    ;; Get balance
    (slice balance_slice, int found) = user_balances.udict_get?(256, user_key);
    return found ? balance_slice~load_coins() : 0;
}